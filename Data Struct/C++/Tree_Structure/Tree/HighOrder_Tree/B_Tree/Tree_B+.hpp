#pragma once



/// <summary>
/// 索引节点中的元素为每个子节点的末尾元素
/// 定义算法等建议看WikiPidia，详细且有存储图，实现上和教材上有些不一样
/// 运行效果见https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html
/// 
/// 总结：
/// B+树的叶子是一个链表
/// 索引节点和叶子节点结构不同，但是此处公用一种struct
/// 索引节点之间类似B―树，
/// 但是索引节点与最底层的叶子节点需要注意：每一个索引元素存叶子节点的分割元素(在叶子上出现的)
///		最底层的索引节点只存右孩子首元素key(最左孩子元素key不存)
///		非最底层的索引节点分割元素时，不同于最底层索引节点，需要像B-树一样将分割元素移到上层
///		(这样效果是高层索引元素也一一对应叶子的右孩子首元素key)
///		
/// 
/// </summary>

template <typename KeyType,typename DataType>
struct BPlus_Node
{
	KeyType* keys;			  // 主键 最大max个 最小min个
	DataType* data;		  // 真实数据  最大max个 最小min个 对于内部结点 data是nullptr
	BPlus_Node** child; // 子节点 最大max+1个 最小min+1个
	BPlus_Node* next;	  // 指向兄弟结点 仅仅是叶子结点的时候才有值
	BPlus_Node* parent;
	int count;			  // 当前元素个数
};


///索引节点元素，取该元素右子树的最小元素(即分割元素)
template <typename KeyType, typename DataType,size_t Order>
class BPlus_Tree
{
private:
	BPlus_Node* root;
	size_t max;///最大阶数
	constexpr size_t min{ max / 2 };///最小阶数(默认写死为 max / 2)

public:
	///初始化orders阶的B+树，默认每个节点最少为orders/2   (n阶节点最多有n-1个元素)
	BPlus_Tree() = default;
	~BPlus_Tree() = default;
	//BPlus_Tree* BPlus_Tree_Init(int orders);
	//void BPlus_Tree_Destroy(BPlus_Tree* tree);

private:
	//创建新的内部结点
	BPlus_Node* Create_Branch();
	//创建新的叶子结点
	BPlus_Node* Create_Leaf();

public:
	void Element_Insert(KeyType key, DataType element);

	void Element_Delete(KeyType key);

	///搜索叶子中key所对应的元素数据
	DataType Search(KeyType key);

	void Show()
	{
		//BPlus_Level_Show(tree->root, 0);

		auto node = tree->root;
		int level = 1;
		while (node->child)
		{//所有叶子节点深度相同
			++level;
			node = node->child[0];
		}

		std::vector<BPlus_Node*>* buffer = new std::vector<BPlus_Node*>[level];
		BackTrace_Traverse(buffer, tree->root, 0);

		std::cout << "Tree=======================================" << std::endl;
		Print_Tree(buffer, level);
		std::cout << "===========================================" << std::endl;
		delete[] buffer;
	}

};


#include <vector>
std::vector<std::vector<BPlus_Node*>> buffer;
int level = 0;
///回溯实现遍历生成所有树中的节点信息，存入数组
static void BackTrace_Traverse(std::vector<BPlus_Node*>*& buffer, BPlus_Node* node, int level)
{
	if (!node)
		return;

	buffer[level].push_back(node);
	if (!node->child)
		return;

	for (int i = 0; i <= node->count; ++i)
	{//遍历所有孩子节点，加入对应层的数组中
		level++;
		//if(i==node->count && !node->child[i])


		BackTrace_Traverse(buffer, node->child[i], level);
		level--;
	}
}

void Print_Tree(std::vector<BPlus_Node*>*& buffer, int level)
{

	///以行为单位显示每一层的节点
	for (int i = 0; i < level - 1; ++i)
	{
		///索引节点稍微居中一些显示
		for (int j = 0; j < (level - i); ++j)
			std::cout << '\t';

		for (const auto& node : buffer[i])//索引节点格式化
		{
			Node_Print(node);
			std::cout << '\t';
		}
		std::cout << std::endl;
	}

	///显示最底层的叶子节点
	auto node = buffer[level - 1][0];
	while (node)
	{
		Node_Print(node);
		if (node->next)
		{
			std::cout << "->";
			node = node->next;
		}
		else
		{
			std::cout << "\n";
			return;
		}
	}


}




